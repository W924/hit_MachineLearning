# coding:utf-8
import numpy as np
import random
import matplotlib.pyplot as plt


# 随机生成数据
def generate_data():
    data = []
    mean1 = [1, 1]
    cov1 = [[1, 0], [0, 1]]
    x1, x2 = np.random.multivariate_normal(mean1, cov1, np.random.randint(10, 20)).T
    for i in range(len(x1)):
        data.append([x1[i], x2[i]])
    mean2 = [4, 1]
    cov2 = [[1, 0], [0, 1]]
    x1, x2 = np.random.multivariate_normal(mean2, cov2, np.random.randint(10, 20)).T
    for i in range(len(x1)):
        data.append([x1[i], x2[i]])
    mean3 = [4, 4]
    cov3 = [[1, 0], [0, 1]]
    x1, x2 = np.random.multivariate_normal(mean3, cov3, np.random.randint(10, 20)).T
    for i in range(len(x1)):
        data.append([x1[i], x2[i]])
    return data


# 从文件中读取数据
def load_data():
    x_set = []
    fp = open('data1.txt')
    for line in fp.readlines():
        line_array = line.strip().split()
        x_set.append([float(line_array[0]), float(line_array[1])])
    return x_set


def k_means(data, k):
    means = random.sample(data, k)       # 算法开始时随机选择k个样本作为初始均值向量
    label = []                          # 标签集合
    for n in range(len(data)):
        label.append(0)
    # data_divide = []
    while True:
        divide = [[0 for col in range(0)] for row in range(k)]
        # 根据当前各类的中心点，对每个数据贴标签
        for i in range(len(data)):
            distance = float('inf')
            sample_label = 0
            # 确定最近的中心点
            for j in range(len(means)):
                temp = np.sqrt(np.square(data[i][0] - means[j][0]) + np.square(data[i][1] - means[j][1]))
                if temp < distance:
                    distance = temp
                    sample_label = j
            label[i] = sample_label
            divide[sample_label].append(data[i])
        flag = True
        # 重新计算各类的新均值向量
        for i in range(k):
            x1_sum = float(0)
            x2_sum = float(0)
            for j in range(len(divide[i])):
                x1_sum += divide[i][j][0]
                x2_sum += divide[i][j][1]
            # 新的均值向量
            x1_mean = x1_sum / len(divide[i])
            x2_mean = x2_sum / len(divide[i])
            if (x1_mean != means[i][0]) | (x2_mean != means[i][1]):
                flag = False
            means[i] = [x1_mean, x2_mean]
        # 如果均值向量未更新，则退出
        if flag is True:
            data_divide = divide
            break
    return label, data_divide


data_set = generate_data()          # 二维数组
label_set, divide_set = k_means(data_set, 3)
y1 = divide_set[0]
y2 = divide_set[1]
y3 = divide_set[2]
print len(y1)
print len(y2)
print len(y3)
x11 = []
x12 = []
x21 = []
x22 = []
x31 = []
x32 = []
for m in range(len(y1)):
    x11.append(y1[m][0])
    x12.append(y1[m][1])
for m in range(len(y2)):
    x21.append(y2[m][0])
    x22.append(y2[m][1])
for m in range(len(y3)):
    x31.append(y3[m][0])
    x32.append(y3[m][1])
print x11

plt.plot(x11, x12, marker='.', color='blue', linestyle='')
plt.plot(x21, x22, marker='.', color='red', linestyle='')
plt.plot(x31, x32, marker='.', color='green', linestyle='')
plt.show()
